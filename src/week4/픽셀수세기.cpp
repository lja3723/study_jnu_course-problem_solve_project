//소프트웨어공학과 201986 이장안
#include <cstdio>
#include <iostream>

using namespace std;

namespace week4_counting_pixels {

	//주어진 좌표 x, y가 반지름이 R인 원 내부에 속해 있는 지 여부를 반환한다.
	//만약 경계에 정확히 걸쳐있는 점이라면 false이다.
	bool isInside(long long x, long long y, long long R) {
		//원의 부등식 공식(x^2 + y^2 < R^2)을 이용, 주어진 좌표가 원 안의 점인지 확인한다.
		return x * x + y * y < R * R;
	}

	//픽셀로 이루어진 반지름 R인 원의 픽셀의 개수를 리턴한다.
	long long getPixelsCount(int R) {
		//원의 중심은 원점이라고 가정한다.
		//원은 대칭성이 있으므로, 4등분 한 뒤 오른쪽 위, 즉 제1사분면에 해당하는 사분원에 속한 픽셀의 개수를 센다.

		long long cnt = 0; //구하고자 하는 픽셀 수의 총 합이다. 결과가 int 최대범위를 넘어갈 수 있으므로 long long을 이용한다.

		//(x, y)는 픽셀의 왼쪽 밑의 좌표를 의미한다.
		//(0, R - 1) 좌표부터 탐색을 시작한다.
		int x = 0, y = R - 1;

		//점의 x좌표를 1씩 증가시켜가면서 x가 R - 1가 될 때까지 선형적으로 탐색한다.
		for (x = 0; x < R; x++) {
			//(x, y)가 원 안에 들어있지 않은 경우, 원 안에 들어올 때까지 y좌표를 1씩 감소시킨다.
			while (!isInside(x, y, R)) y--;

			//(x, y)가 원 안에 들어왔다면, (x, y) 부터 (x, y - 1), ..., (x, 1), (x, 0)이 모두 원 안에 포함되었다는 의미이다.
			//즉 x좌표가 동일하고 y좌표가 y 이하인 모든 픽셀이 원 안에 있다는 뜻이므로, 이때의 픽셀의 개수는 y + 1이다.
			//따라서 그 값을 카운터에 누적한다.
			cnt += y + 1;
		}

		//사분원의 픽셀의 개수를 구한 것이므로, 4를 곱한 값을 반환한다.
		return cnt * 4;
	}

	int main() {
		int T; cin >> T; //테스트케이스 수를 입력받는다.

		//테스트케이스만큼 반복한다.
		for (int t = 1; t <= T; t++) {
			int R; cin >> R; //픽셀 원의 반지름을 입력받는다.

			cout << "#" << t << endl;
			long long cnt = getPixelsCount(R); //픽셀 원 반지름에 해당하는 원의 총 픽셀 수를 받는다.
			cout << cnt << endl; //픽셀 수를 출력한다.
		}

		return 0;
	}
}

//문제풀이를 담당하는 main문을 호출한다. (주석 해제 후 실행)
//int main() { return week4_counting_pixels::main(); }

/*
	>> input
2
1
5
	<< output
#1
4
#2
88

	>> input
10
100000
99999
99998
99997
99996
99995
99994
99993
99992
99991
	<< output
#1
31416325412
#2
31415696920
#3
31415069480
#4
31414441300
#5
31413811792
#6
31413184112
#7
31412555868
#8
31411927608
#9
31411299368
#10
31410671260
*/